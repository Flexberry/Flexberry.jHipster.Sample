# Микросервисы

Микросервисная архитектура — это подход к созданию приложения в виде набора независимых сервисов, которые взаимодействую между собой по сети.

JHipster может генерировать проекты с микросервисной архитектурой. Для этого необходимо ответить на соответствующий вопрос на предварительном этапе генерации.

Полная схема микросервисного подхода выглядит так:

[Общая структура микросервисов JHipster](images/Microservices.jpg)

На схеме синим цветом отмечены базовые компоненты, которые создает JHIpster при выборе микросервисного подхода, а зеленым, элементы, зависящие от проекта.
Базовый общий принцип такого подхода состоит в четком разделении сервисов по принципу бэкенд-фронтэнд.

##Архитектура микросервисной системы JHipster состоит из следующих компонентов:

**Шлюз (Gateway)** - это приложение, сгенерированное JHipster (используя тип microservice gateway), которое обрабатывает веб-трафик. Шлюз - это входная точка системы. Он обеспечивает HTTP-маршрутизацию и доступ к сервисам, балансировку нагрузки и безопасность. Также шлюз берет на себя роль wiki и хранит документацию по API всех сервисов.

**JHipster Registry и альтернатива Consul** - это discovery сервисы. Эти сервисы выполняют три задачи - хранят метаинформацию о всех сервисах системы (например конфиги), регистрируют и отслеживают доступность компонентов системы, обнаруживают компоненты автоматически. Например, все сервисы при старте регистрируются в discovery-сервисе и получают свои конфиги.

**Сами микросервисы** - это генерируемые JHipster приложения (с application type microservice application), которые обрабатывают REST запросы. Может быть несколько одинаковых микросервисов, работающих параллельно.

##Шлюз

Шлюс представляет из себя комплекс, состоящий из

**Spring Cloud Gateway**

Это прокси-сервис, выполненный в виде Spring-boot приложения. Все запросы проходят через него, поэтому он выступает единственной точкой входа для пользователя и координатором для сервисов, 
благодаря чему, сервисы не должны знать друг о друге. Например шлюз будет работать на localhost:8080, и доступ ко всем сервисам будет происходить через localhost:8080 (например http://localhost:8080/services/app1/api/foos)

[Ссылка на репозиторий](https://github.com/spring-cloud/spring-cloud-gateway)

**Spring Cloud LoadBalancer**

Часто, чтобы создать отказоустойчивую систему, запускают сразу несколько экземпляров одного и того же сервиса. LoadBalancer, используя определенный алгоритмы, распределяет запросы между ними. 

[Документация Spring Cloud LoadBalancer](https://spring.io/guides/gs/spring-cloud-loadbalancer/)

**Netflix Hystrix**

Hystrix — это библиотека, решающая проблемы с задержкой и повышающая отказоустойчивость в распределенных системах. Предназначена для изоляции точек доступа к удаленным системам, службам и сторонним библиотекам для предотвращения каскадных сбоев.

Данный инструмент прекратил развитие и сейчас находится в режиме обслуживания.

[Репозиторий Hystrix](https://github.com/Netflix/hystrix)

**Java JWT**

Java JWT это библиотека для создания и проверки веб-токенов JSON для Java и Android. В составе шлюза Java JWT обеспечивает безопасность соединений. Также Шлюз может работать с keycloak, но JWT более предпочтительный вариант.

[Репозиторий Java JWT](https://github.com/jwtk/jjwt)

**Swagger**

Swagger — это набор инструментов, который позволяет автоматически описывать API на основе его кода. Swagger состоит из онлайн сервиса и API клиента, добавляемого в приложение. Вся документация формируется на сервере Swagger.

[официальный ресурс Swagger](https://swagger.io/)

**Ограничение скорости**

Шлюз использует функцию ограничения скорости для обеспечения качества работы микросервисов. Для этого используются интсрументы Bucket4j и Hazelcast. По умолчанию в шлюзе выставлено ограничение 100 000 вызовов API в час.
В этой связке Hazelcast занимается подсчетом вызовов, а Bucket4j ограничивает скорость. Hazelcast на самом деле очень большой инструмент, выполняющий множество функций поддержки распределенных систем.

[Официальный ресурс Hazelcast](https://hazelcast.com/)
[Репозиторий Bucket4j](https://github.com/bucket4j/bucket4j)

##JHipster Registry

Это продукт генерации JHipster. Но он также имеет и свой отдельный репозиторий. JHipster Registry это сервер конфигурации Spring. Когда сервисы запускаются, они сначала подключаются к реестру JHipster, чтобы получить свою конфигурацию.
Эта конфигурация представляет собой конфигурацию Spring Boot, подобную той, что находится в application-*.yml файлах JHipster, но она хранится на центральном сервере, поэтому ею легче управлять. JHipster Registry состоит из трех компонентов:

- Cервер Eureka, который служит сервером обнаружения для приложений. Этот сервер ведет динамический список доступных экземпляров приложений, которые затем используются микрослужбами для маршрутизации HTTP-запросов и балансировки нагрузки.

- Spring Cloud Config. Обеспечивает настройку сервисов в рантайм режиме.

- Administration server - дашборд для управления и администрирования JHipster Registry.

[Репозиторий JHipster Registry](https://swagger.io/)
[Статья по Eureka](https://swagger.io/)

##Consul

Альтернатива JHipster Registry. Consul это решение для управления центром обработки данных от Hashicorp. По сравнению с Eureka (в составе JHipster Registry) имеет ряд преимуществ:

- В многоузловом кластере работать проще, чем в Eureka.

- Изменения в состоянии вашего кластера распространяются быстрее.

- Служба обнаружения Consul может взаимодействовать с существующими приложениями через свой DNS-интерфейс или HTTP API.

[Официальный ресурс Consul](https://www.consul.io/)