# Кэширование

Кэширование позволяет вызывать ресурсоемкие методы (независимо от того, связаны ли они с процессором или вводом-выводом) только один раз для заданного набора параметров, а результат может быть повторно использован без необходимости повторного вызова метода.

В JHipster предусмотрена возможность использования кэша на 2 уровнях:
1. С абстракцией Spring Cache, используя аннотацию Spring Boot @EnableCaching. Его необходимо настроить в соответствии с конкретными потребностями, и он работает на более высоком уровне, чем кэш второго уровня Hibernate.
2. Hibernate 2-го уровня может значительно повысить производительность приложения. Этот параметр доступен только для баз данных SQL совместно со Spring Cache.

Spring Cache и Hibernate 2-го уровня могут использовать оно и то же решение для кэшировния, но не должны работать на одном уровне. Не рекомендуется использовать Spring Cache и Hibernate 2-го уровня для одних и тех же объектов, так как это еще больше усложнит проблемы инвалидации кэша. Рекомендуется придерживаться следующих принципов:
- Spring Cache использовать для объектов более высокого уровня или агрегированных объектов, как это обычно бывает с DTO.
- Кэш Hibernate 2-го уровня – для сущностей, сопоставленных с базой данных, чтобы уменьшить количество SQL-запросов.

В JHipster поддерживаются следующие реализации кэширования:
- [Ehcache](#Ehcache)
- [Caffeine](#Caffeine)
- [Hazelcast](#Hazelcast)
- [Infinispan](#Infinispan)
- [Memcached](#Memcached)
- [Redis](#Redis)


## <a id="Ehcache">Ehcache</a>
[Ehcache](https://www.ehcache.org/) — это кэш с открытым исходным кодом, основанный на стандартах, который повышает производительность, разгружает базу данных и упрощает масштабирование. Это наиболее широко используемый кэш на основе Java, поскольку он надежный, проверенный, полнофункциональный и интегрируется с другими популярными библиотеками и платформами. Ehcache масштабируется от внутрипроцессного кэширования до смешанных внутрипроцессных / внепроцессных развертываний с терабайтным кэшем.

Особенности Ehcache 3:
- Обновленный API, который использует дженерики Java и упрощает взаимодействие с кэшем.
- Полная совместимость с API javax.cache (JSR-107 - спецификация JCache).
- Возможности хранения вне кучи, включая кэширование только вне кучи.
- Готовая интеграция Spring Caching и Hibernate благодаря поддержке javax.cache.
- И многое другое.

Для использования Ehcache 3 необходимо:
1. Скачать с github jar-файл Ehcache или подключить через зависимости в Maven.
2. Подключить в зависимостях Maven актуальную версию JSR-107 API.

Последняя версия, на момент написания: 3.10 от 12 апреля 2023.

Требуется: Java 8+.

Для приложений, требующих полной корпоративной функциональности, включая консоль мониторинга управления (TMC), быстро перезапускаемое хранилище (FRS), безопасность и многое другое — наряду с профессиональной поддержкой по всему миру, рекомендуется использовать [Terracotta BigMemory Max](https://documentation.softwareag.com/terracotta/terracotta_4310/bigmemory-max/webhelp/index.html#page/bigmemory-max-webhelp%2Fco-over_what_is_bigmem_max.html%23wwconnect_header).


## <a id="Caffeine">Caffeine</a>
[Caffeine](https://github.com/ben-manes/caffeine) — это высокопроизводительная библиотека с почти оптимальным кэшированием. Подобно Ehcache, Caffeine не может работать как распределенный кэш. Caffeine обеспечивает кэширование в памяти с использованием API, основанном на Google Guava. Улучшения основаны на опыте разработки Guava Cache и ConcurrentLinkedHashMap.

Caffeine обеспечивает гибкость для создания кэша с комбинацией следующих дополнительных функций:
- автоматическая загрузка записей в кэш, опционально асинхронно;
- вытеснение записей при превышении максимально допустимого значения частоты и срока давности;
- истечение срока действия записей, измеряемое с момента последнего доступа или последней записи;
- асинхронное обновление, при появлении первого устаревшего запроса на запись;
- ключи автоматически завернуты в слабые ссылки;
- значения автоматически завернуты в слабые или мягкие ссылки;
- уведомление о вытесненных (или иным образом удаленных) записях;
- записи распространяются на внешний ресурс;
- накопление статистики доступа к кэшу.

Последняя версия, на момент написания: 3.1.6 от 7 апреля 2023.

Для Java 11 или выше рекомендуется использовать Caffeine 3.x, в противном случае используйте Caffeine 2.x.

Подключение Caffeine происходит через зависимости в Maven или Gradle.


## <a id="Hazelcast">Hazelcast</a>
[Hazelcast](https://hazelcast.com/) — это распределенная платформа для вычислений и хранения данных, обеспечивающая последовательное выполнение запросов с малой задержкой, агрегацию и вычисления с отслеживанием состояния для потоков событий и традиционных источников данных. Она позволяет быстро создавать ресурсоэффективные приложения реального времени. Вы можете развернуть его в любом масштабе — от небольших пограничных устройств до большого кластера облачных экземпляров. Hazelcast может обрабатывать данные на наборе сетевых и кластерных компьютеров, которые объединяют свои оперативные запоминающие устройства (ОЗУ), чтобы приложения могли обмениваться данными с другими приложениями, работающими в кластере. Таким образом, Hazelcast может работать как локальный кэш (например, как Ehcache), но также может работать как распределенный кэш.

Благодаря Java-клиенту для Hazelcast, самое быстрое решение для кэширования с открытым исходным кодом теперь доступно для Java-приложений в клиент-серверном режиме развертывания. Кэширование Java с гибким масштабированием. Hazelcast — отличная альтернатива Redis, когда важны масштабирование и скорость.

Чтобы использовать Hazelcast вместе с Java, можно воспользоваться одним из трёх способов:
1. Добавить в качестве зависимости в Maven.
2. Скачать [Hazelcast jar-файл](https://repo1.maven.org/maven2/com/hazelcast/hazelcast/5.3.0/hazelcast-5.3.0.jar) и подключить в проекте.
3. Установить, как отдельный модуль Java.

Последняя версия Hazelcast IMDG Java Client, на момент написания: 5.3.0 от 19 мая 2023.

Требования последней версии Hazelcast к JDK, ОС и прочее можно посмотреть [тут](https://docs.hazelcast.com/hazelcast/latest/deploy/versioning-compatibility). 


## <a id="Infinispan">Infinispan</a>
[Infinispan](https://infinispan.org/) — это масштабируемое хранилище данных с открытым исходным кодом, предлагает гибкие варианты развертывания и надежные возможности для хранения, управления и обработки данных. Infinispan предоставляет хранилище данных типа «ключ-значение», в котором могут храниться все типы данных, от объектов Java до простого текста. Infinispan распределяет данные по гибко масштабируемым кластерам, чтобы гарантировать высокую доступность и отказоустойчивость, независимо от того, используется ли Infinispan в качестве энергозависимого кэша или постоянного хранилища данных. Infinispan часто используется как распределенный кэш, а также как хранилище ключей/значений NoSQL или объектная база данных.

Один из вариантов  использования Infinispan - это кэширование. Использование Infinispan с базой данных, дисковым хранилищем NoSQL или любой частью системы, которая является узким местом, может значительно повысить производительность. Однако часто простого кэша недостаточно — например, если приложение кластеризовано и когерентность кэша важна для согласованности данных. В данном случае может помочь распределенный кэш. Infinispan предлагает несколько [вариантов кэширования](https://infinispan.org/docs/9.4.x/user_guide/user_guide.html#which_cache_mode_should_i_use) под разные потребности.

Infinispan также можно использовать в качестве высокопроизводительного хранилища данных NoSQL. Помимо хранения в памяти, Infinispan также может сохранять данные в более постоянном хранилище, так называемом кэш-хранилище.

Еще одним распространенным вариантом использования является добавление кластеризации и высокой доступности к фреймворкам. Поскольку Infinispan предоставляет распределенную структуру данных, фреймворки и библиотеки, которые также необходимо кластеризовать, для этого необходимо встроить Infinispan и делегировать Infinispan все управление состоянием. Таким образом, любую инфраструктуру можно легко кластеризовать, позволяя Infinispan выполнять всю тяжелую работу.

По своей сути Infinispan предоставляет Cache-интерфейс, который расширяет java.util.Map. Он также дополнительно поддерживается архитектурой одноранговой сети для эффективного распределения данных по кластеру серверов.

В дополнение к своему основному API Java, Infinispan также может использоваться платформами, отличными от JVM, с использованием протокола Hot Rod, для которого существуют клиентские библиотеки для различных платформ.

Infinispan полностью транзакционный. Infinispan поддерживает как стандарты JTA, так и стандарты XA, и может участвовать в распределенных транзакциях, проводимых при посредничестве действительного менеджера транзакций JTA.

Для работы с Infinispan нужны: 
1. Java.
2. Инструмент управления зависимостями (Maven, Gradle или Ivy).
3. Сервер Infinispan или основные библиотеки.

Последняя версия Infinispan Development Release, на момент написания: 15.0.0.Dev01 от 24 мая 2023.

Для запуска Infinispan требуется:
- Минимум Java 11 JDK.
- Maven 3.2 или более поздние версии.


## <a id="Memcached">Memcached</a>
[Memcached](https://memcached.org/) — бесплатная, с открытым исходным кодом, высокопроизводительная система кэширования объектов с распределенной памятью, универсальная по своей природе, но предназначенная для использования в ускорении динамических веб-приложений за счет снижения нагрузки на базу данных.

Memcached представляет собой хранилище ключей и значений в памяти для небольших фрагментов произвольных данных (строк, объектов) из результатов запросов к БД, вызовов API или рендеринга веб-страницы.

Memcached достаточно прост, но, в то же время, это мощный инструмент. Его простая конструкция способствует быстрому развертыванию, простоте разработки и решает многие проблемы, связанные с кэшированием больших объемов данных. Memcached API доступен для большинства популярных языков.

Особенности Memcached:
- Не может работать как кэш второго уровня Hibernate, он поддерживает только абстракцию Spring Cache.
- Работает только с удаленным сервером, локального кэша нет. Таким образом, объекты всегда сериализуются/десериализуются и проходят через сеть, что означает, что это, вероятно, менее эффективно, если есть небольшой набор объектов, которые могут поместиться в памяти.
- Масштабируется и дешев в эксплуатации. 
- Большинство крупных облачных провайдеров, таких как Heroku, GCP или AWS, поддерживают Memcached. 

Таким образом, гораздо проще иметь распределенный (и дешевый) кластер Memcached, по сравнению с другими реализациями кэширования.

Поскольку Memcached должен сериализовать/десериализовать объекты в своем загрузчике классов, он не работает при использовании инструментов разработки Spring Boot (который использует специальный загрузчик классов для горячей перезагрузки классов приложений). Вот почему Memcached по умолчанию отключен в режиме разработки.

Для работы с Memcached нужно:
1. Развернуть сервер Memcached.
2. Добавить в зависимости Java-клиент XMemcached.

[XMemcached](https://github.com/killme2008/xmemcached) — это высокопроизводительный, простой в использовании, блокирующий многопоточный клиент Memcached, написанный на языке java.

Последняя версии на момент написания: 
- Memcached 1.6.20 от 12 мая 2023.
- XMemcached 2.4.7 от 6 января 2021.	

Memcached работает на большинстве Linux и BSD подобных системах. Официальной поддержки сборок для Windows нет. Требования предъявляемые к ресурсам (железу) можно посмотреть [тут](https://github.com/memcached/memcached/wiki/Hardware).


## <a id="Redis">Redis</a>
[Redis](https://redis.io/) - это хранилище данных в памяти с открытым исходным кодом, используемое миллионами разработчиков в качестве базы данных, кэша, механизма потоковой передачи и брокера сообщений. В зависимости конфигурации вы можете использовать Redis как отдельный серверный узел или как распределенный кэш.

Redis работает со структурами данных, такими как строки, хэши, списки, наборы, отсортированные наборы с диапазонными запросами, растровые изображения, гиперлоглоги, геопространственные индексы и потоки. Redis имеет встроенную репликацию, сценарии Lua, вытеснение LRU, транзакции и различные уровни сохраняемости на диске, а также обеспечивает высокую доступность с помощью [Redis Sentinel](https://redis.io/topics/sentinel) и автоматического разделения с помощью [Redis Cluster](https://redis.io/topics/cluster-tutorial).

Для достижения максимальной производительности Redis работает с набором данных в памяти. В зависимости от варианта использования, Redis может сохранять данные либо путем периодического сброса набора данных на диск, либо путем добавления каждой команды в журнал на диске. Можно отключить сохранение, если просто нужен многофункциональный сетевой кэш в памяти.

Redis поддерживает асинхронную репликацию с быстрой неблокирующей синхронизацией и автоматическим повторным подключением с частичной повторной синхронизацией при разделении сети.

Redis написан на ANSI C и работает в большинстве систем POSIX, таких как Linux, *BSD и Mac OS X, без внешних зависимостей. Linux и OS X — это две операционные системы, в которых Redis разрабатывается и тестируется чаще всего, рекомендуется использовать Linux для развертывания. Redis может работать в системах, производных от Solaris, таких как SmartOS. Официальной поддержки сборок Windows нет, но есть возможность развертывания [в Windows 10 версии 2004 и выше или в Windows 11](https://redis.io/docs/getting-started/installation/install-redis-on-windows/).

Для работы с Redis нужно:
1. Установить Redis.
2. Добавить Java-клиент Redisson в зависимости. Поддерживают инструменты сборки: Maven, Gradle и SBT. 

[Redisson](https://redisson.org/) — легкий Java-клиент Redis
с функциями масштабируемых хранилищ данных. Основан на высокопроизводительном асинхронном и свободном от блокировки клиенте Java Redis и фреймворке Netty.

Поддерживает JDK: 1.8 - 20 и Android.

Поддерживает Redis: 3.0 - 7.0.

Альтернативные варианты Java-клиентов можно посмотреть [тут](https://redis.io/resources/clients/#java).

Последняя версии на момент написания: 
- Redis 7.0.11 от 17 апреля 2023.
- Redisson 3.21.3 от 18 мая 2023.


## Источники
1. [Ehcache Documentation](https://www.ehcache.org/documentation/)
2. [Caffeine User's Guide](https://github.com/ben-manes/caffeine/wiki)
3. [Hazelcast Reference Manual](https://docs.hazelcast.com/hazelcast/5.3/getting-started/get-started-cli)
4. [Infinispan Guides](https://infinispan.org/documentation/)
5. [Memcached Wiki](https://github.com/memcached/memcached/wiki)
6. [XMemcached Getting started](https://github.com/killme2008/xmemcached/wiki/Getting%20started)
7. [Getting started with Redis](https://redis.io/docs/getting-started/)
8. [Redisson documentation](https://github.com/redisson/redisson/wiki/Table-of-Content)